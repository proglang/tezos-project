% APLAS 2021: Regular research papers should not exceed 18 pages in
% the Springer LNCS format(LaTeX template), including bibliography and
% figures.
% Lightweight double-blind: Author names and institutions must be
% omitted and References to the authorsâ€™ own related work should be in
% the third person 
%
\documentclass[runningheads]{llncs}
\pdfoutput=1
%\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{graphicx}
%\usepackage[colorinlistoftodos]{todonotes}
\usepackage{mathpartir}
\usepackage{graphicx}
%\usepackage{fixme}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{titling}

%\input{macros}
%\input{setup}

% ------------------- colors -------------------
\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}
\definecolor{UniBlue}{RGB}{0, 74, 153}
\definecolor{UniRed}{RGB}{193, 0, 42}
\definecolor{UniGrey}{RGB}{154, 155, 156}
\definecolor{cverbbg}{gray}{0.93}

\newcommand{\todo}[1]{\textbf{\textcolor{red}{(TODO: #1)}}}

\begin{document}
%
\title{Assertion Contracts}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Thi Thu Ha Doan\orcidID{0000-0001-7524-4497}\and Peter Thiemann\orcidID{0000-0002-9000-1239}}

%
%\authorrunning{Ha Doan, P. Thiemann}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
%\institute{University of Freiburg, Germany \\ \email{\{doanha,thiemann\}@informatik.uni-freiburg.de}
%}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}

 \keywords{}
\end{abstract}
%
%
%
\section{Introduction}
\label{sec:introduction}

Every computation performed by a Smart Contract on the blockchain generates costs. Each
unit of computation and each unit of storage used by an algorithm must be paid for. To
avoid this cost, an application might perform some computation away from the blockchain
(i.e., off-chain) and submit the result as a parameter to a contract on the
blockchain. Typically, such a computation asserts certain properties of the 
submitted parameter. 

However, this approach raises the issue that on the one hand the contract should take
advantage of the offchain computation and assume that the submitted parameter has
these properties, but on the other hand, the off-chain computation might be wrong and
submit illegal parameters. So, we need a mechanism that checks the validity of the
assumptions before the contract starts executing.

As an example, consider a contract that takes a prime number as a parameter.
\begin{lstlisting}[numbers=none]
contract Example {
  function (int p) public {
    // assume p is prime
    ...
  }
}
\end{lstlisting}
This assumption can be expressed with an explicit assertion in predicate logic.
\begin{gather}\label{eq:5}
  (\forall n) (2 \le n \le \sqrt p) \Rightarrow (p \mathbin{\%} n) \ne 0
\end{gather}
To test the validity of this assumption requires a loop in the contract, but the test would take
$O(\sqrt p)$ time (assuming constant time for computing the remainder) and thus produce extra cost
linear in $\sqrt p$ accordingly. 
However, we could do better by recruiting the validators of the contract for a distributed
effort to find a counterexample. To this end, we consider the negation of the assertion.
\begin{gather}\label{eq:4}
  (\exists n) (2 \le n \le \sqrt p) \wedge (p \mathbin{\%} n) = 0
\end{gather}
This assertion can be checked pointwise by having each validator independently choose a
random $n$ fulfilling $2 \le n \le 
\sqrt p$ and checking whether $(p \mathbin{\%} n) = 0$. If the remainder is $0$, the
validator found a counterexample, posts its veto to the P2P net, and stops further
exection. Otherwise, it accepts $p$ knowing that other points will be checked by other
validators.

In this scenario, each validator only needs to be paid to generate a random number and
perform a division, which is a constant cost independent from $p$.

Of course, this validation is only probabilistic, so its effectiveness depends on the
number of validators. One could say that the community of validators implements a Bloom
filter for the set of primes: if a value $p$ is rejected it is certainly not a prime (because
there exists a counterexample); if a value $p$ is not rejected it is prime with a
probability that depends on $p$ and the number of validators. 

As another example, consider a contract that takes a sorted array of integers.
\begin{lstlisting}[numbers=none]
contract Sorted {
  function find (int[50] a, int v) public {
    // assume a is sorted
  }
}
\end{lstlisting}
The explicit assertion would be
\begin{gather}\label{eq:1}
  (\forall k) (0\le k <49) \Rightarrow a[k] \le a[k+1]
\end{gather}
While we can check this contract in $O(1)$ time, the constant factor is big! So we
consider its negation.
\begin{displaymath}
  (\exists k) (0\le k <49) \wedge a[k] > a[k+1]
\end{displaymath}
Again, we can have every validator generate a random number $k$. If the
condition is true for such $k$, then the validator found a counterexample for the sortedness
of the array. Otherwise, the validator relies on the other validators to check
different numbers.

%To obtain an estimate of the number of validators needed to find a counterexample with high probibility, let's assume the array is unsorted only at position $0$, the size of the array is $n$,and the number of validators is $m$. Each validator independently has a probability of $1/n$ to detect the problem and thus probability $\frac{n-1} n$ not to detect the problem. Hence, if we assume that each $k$ is chosen independenty from a uniform distribution, the probability that no validator checks at position $0$ converges to $0$ as the number of validators approaches infinity.
%\begin{displaymath}
%  \lim_{m\to\infty}\frac{(n-1)^m}{n^m}
%  = \lim_{m\to\infty} \left(\frac{n-1}{n}\right)^m
%  = 0
%\end{displaymath}

In Dafny (citation) \url{https://rise4fun.com/Dafny/tutorialcontent/guide#h29} you can
write
\begin{lstlisting}
forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]
\end{lstlisting}
to express that an array is sorted. This predicate is equivalent to the one given in
\eqref{eq:1}, but it might be more challenging to test. Its negation is
\begin{gather}
  \label{eq:2}
  (\exists j, k ) (0\le j< k < |a|) \wedge a[j] > a[k]
\end{gather}
So we'd have to generate two random numbers $j$ and $k$ such that the condition $0 \le
j < k < |a|$ is fulfilled.


Another condition that might be tested on an array is the heap condition
\begin{gather}
  \label{eq:3}
  (\forall i) (0 \le i < \lfloor|a|/2\rfloor) \Rightarrow a[i] \le a[2i+1] \wedge (2i+2
  < |a| \Rightarrow a[i] \le a[2i+2])
\end{gather}

\section{Primaries}
\label{sec:primaries}

\section{Parameter Distributed Verification Approach for Blockchain System}
\label{sec:approach}
In this section, we aim to introduce an approach leveraging distributed aspects to address the challenging verification issue within blockchain systems. Specifically, we focus on verifying a substantial parameter, crucial for executing a smart contract call.

Our attention is drawn to the verification problem, which can be articulated as a logical formula presented in conjunction form as follows:

\[ \bigwedge_{i = 1}^{n} P_{i} \]

Verifying the formula centrally becomes resource-intensive, both in terms of time and computer resource when the number $n$ is big or when the predicates $P_{i}$ are complex to compute. 


For instance, the scenario mentioned above can be represented as follows. The verification of whether $p$ is a prime number can be formalized as:

\[ \bigwedge_{i = 2}^{|\sqrt p|} (p \mathbin{\%} i \neq 0) \]

Similarly, ensuring the sorted property for an array of size nn can be expressed as:

\[ \bigwedge_{i = 0}^{n - 2} (a[i] \le a[i+1]) \]

The fundamental concept of our approach is to disjoin this formula and distribute its components to validators in the network. Each validator endeavors to find a counterexample by solving $\neg P_{i}$. When a counterexample is discovered, the formula is proven to fail. If no counterexample is found, the correctness of the formula depends on the number of predicates  $P_{i}$ that have been checked. 


To estimate the number of validators needed to find a counterexample with a given probability $p$, let's assume the number of validators is $m$. Each validator independently has a probability of $p$ to check $P_{i}$. Hence, if we assume that each $P_{i}$ is chosen independently from a uniform distribution, the probability that a validator checks $P_{i}$ is 
\begin{displaymath}
 m. (\frac{1}{n})
\end{displaymath}
So, to detect the counterexample, assuming at $P_{i}$ the number of validators needed is as follows:
\begin{displaymath}
 m \ge p.n
\end{displaymath}

This inequality indicates that the minimum number of validators required, $m$, is at least $p$ times the number $n$, to achieve the desired probability $p$ of detecting the counterexample. Indeed, the estimated number of validators plays a crucial role in designing the protocol for the approach. It serves as a fundamental parameter that influences various aspects of the protocol's design.
\section{Toward the Design of the Protocol}
\label{sec:design}


\section{Target Tezos Blockchain}
\label{sec:tezos}

\end{document}


