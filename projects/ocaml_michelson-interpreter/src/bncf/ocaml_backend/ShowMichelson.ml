(* show functions generated by the BNF converter *)


(* use string buffers for efficient string concatenations *)
type showable = Buffer.t -> unit

let show (s : showable) : string =
    let init_size = 16 in (* you may want to adjust this *)
    let b = Buffer.create init_size in
    s b;
    Buffer.contents b

let emptyS : showable = fun buf -> ()

let c2s (c:char) : showable = fun buf -> Buffer.add_char buf c
let s2s (s:string) : showable = fun buf -> Buffer.add_string buf s

let ( >> ) (s1 : showable) (s2 : showable) : showable = fun buf -> s1 buf; s2 buf

let showChar (c:char) : showable = fun buf ->
    Buffer.add_string buf ("'" ^ Char.escaped c ^ "'")

let showString (s:string) : showable = fun buf ->
    Buffer.add_string buf ("\"" ^ String.escaped s ^ "\"")

let showList (showFun : 'a -> showable) (xs : 'a list) : showable = fun buf ->
    let rec f ys = match ys with
        [] -> ()
      | [y] -> showFun y buf
      | y::ys -> showFun y buf; Buffer.add_string buf "; "; f ys
    in
        Buffer.add_char buf '[';
        f xs;
        Buffer.add_char buf ']'


let showInt (i:int) : showable = s2s (string_of_int i)
let showFloat (f:float) : showable = s2s (string_of_float f)

let rec showStr (AbsMichelson.Str i) : showable = s2s "Str " >> showString i
let rec showHex (AbsMichelson.Hex i) : showable = s2s "Hex " >> showString i

let rec showProg (e : AbsMichelson.prog) : showable = match e with
       AbsMichelson.Contract (typ0, typ, instrs) -> s2s "Contract" >> c2s ' ' >> c2s '(' >> showTyp typ0  >> s2s ", " >>  showTyp typ  >> s2s ", " >>  showList showInstr instrs >> c2s ')'
  |    AbsMichelson.Code instrs -> s2s "Code" >> c2s ' ' >> c2s '(' >> showList showInstr instrs >> c2s ')'


and showInta (e : AbsMichelson.inta) : showable = match e with
       AbsMichelson.IntPos integer -> s2s "IntPos" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.IntNeg integer -> s2s "IntNeg" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'


and showPairSeq (e : AbsMichelson.pairSeq) : showable = match e with
       AbsMichelson.DPairSeq1 (data0, data) -> s2s "DPairSeq1" >> c2s ' ' >> c2s '(' >> showData data0  >> s2s ", " >>  showData data >> c2s ')'
  |    AbsMichelson.DPairSeq2 (data, pairseq) -> s2s "DPairSeq2" >> c2s ' ' >> c2s '(' >> showData data  >> s2s ", " >>  showPairSeq pairseq >> c2s ')'


and showMapSeq (e : AbsMichelson.mapSeq) : showable = match e with
       AbsMichelson.DMapSeq1 (data0, data) -> s2s "DMapSeq1" >> c2s ' ' >> c2s '(' >> showData data0  >> s2s ", " >>  showData data >> c2s ')'
  |    AbsMichelson.DMapSeq2 (data0, data, mapseq) -> s2s "DMapSeq2" >> c2s ' ' >> c2s '(' >> showData data0  >> s2s ", " >>  showData data  >> s2s ", " >>  showMapSeq mapseq >> c2s ')'


and showData (e : AbsMichelson.data) : showable = match e with
       AbsMichelson.DInt inta -> s2s "DInt" >> c2s ' ' >> c2s '(' >> showInta inta >> c2s ')'
  |    AbsMichelson.DStr str -> s2s "DStr" >> c2s ' ' >> c2s '(' >> showStr str >> c2s ')'
  |    AbsMichelson.DByte hex -> s2s "DByte" >> c2s ' ' >> c2s '(' >> showHex hex >> c2s ')'
  |    AbsMichelson.DUnit  -> s2s "DUnit"
  |    AbsMichelson.DTrue  -> s2s "DTrue"
  |    AbsMichelson.DFalse  -> s2s "DFalse"
  |    AbsMichelson.DPair2 pairseq -> s2s "DPair2" >> c2s ' ' >> c2s '(' >> showPairSeq pairseq >> c2s ')'
  |    AbsMichelson.DLeft data -> s2s "DLeft" >> c2s ' ' >> c2s '(' >> showData data >> c2s ')'
  |    AbsMichelson.DRight data -> s2s "DRight" >> c2s ' ' >> c2s '(' >> showData data >> c2s ')'
  |    AbsMichelson.DSome data -> s2s "DSome" >> c2s ' ' >> c2s '(' >> showData data >> c2s ')'
  |    AbsMichelson.DNone  -> s2s "DNone"
  |    AbsMichelson.DBlock datas -> s2s "DBlock" >> c2s ' ' >> c2s '(' >> showList showData datas >> c2s ')'
  |    AbsMichelson.DMap mapseq -> s2s "DMap" >> c2s ' ' >> c2s '(' >> showMapSeq mapseq >> c2s ')'
  |    AbsMichelson.DInstr instr -> s2s "DInstr" >> c2s ' ' >> c2s '(' >> showInstr instr >> c2s ')'


and showInstr (e : AbsMichelson.instr) : showable = match e with
       AbsMichelson.IBLOCK instrs -> s2s "IBLOCK" >> c2s ' ' >> c2s '(' >> showList showInstr instrs >> c2s ')'
  |    AbsMichelson.IDROP  -> s2s "IDROP"
  |    AbsMichelson.IDROP_N integer -> s2s "IDROP_N" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.IDUP  -> s2s "IDUP"
  |    AbsMichelson.IDUP_N integer -> s2s "IDUP_N" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.ISWAP  -> s2s "ISWAP"
  |    AbsMichelson.IDIG_N integer -> s2s "IDIG_N" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.IDUG_N integer -> s2s "IDUG_N" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.IPUSH (typ, data) -> s2s "IPUSH" >> c2s ' ' >> c2s '(' >> showTyp typ  >> s2s ", " >>  showData data >> c2s ')'
  |    AbsMichelson.ISOME  -> s2s "ISOME"
  |    AbsMichelson.INONE typ -> s2s "INONE" >> c2s ' ' >> c2s '(' >> showTyp typ >> c2s ')'
  |    AbsMichelson.IUNIT  -> s2s "IUNIT"
  |    AbsMichelson.INEVER  -> s2s "INEVER"
  |    AbsMichelson.IIF_NONE (instrs0, instrs) -> s2s "IIF_NONE" >> c2s ' ' >> c2s '(' >> showList showInstr instrs0  >> s2s ", " >>  showList showInstr instrs >> c2s ')'
  |    AbsMichelson.IPAIR  -> s2s "IPAIR"
  |    AbsMichelson.IPAIR_N integer -> s2s "IPAIR_N" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.ICAR  -> s2s "ICAR"
  |    AbsMichelson.ICDR  -> s2s "ICDR"
  |    AbsMichelson.IUNPAIR  -> s2s "IUNPAIR"
  |    AbsMichelson.IUNPAIR_N integer -> s2s "IUNPAIR_N" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.ILEFT typ -> s2s "ILEFT" >> c2s ' ' >> c2s '(' >> showTyp typ >> c2s ')'
  |    AbsMichelson.IRIGHT typ -> s2s "IRIGHT" >> c2s ' ' >> c2s '(' >> showTyp typ >> c2s ')'
  |    AbsMichelson.IIF_LEFT (instrs0, instrs) -> s2s "IIF_LEFT" >> c2s ' ' >> c2s '(' >> showList showInstr instrs0  >> s2s ", " >>  showList showInstr instrs >> c2s ')'
  |    AbsMichelson.INIL typ -> s2s "INIL" >> c2s ' ' >> c2s '(' >> showTyp typ >> c2s ')'
  |    AbsMichelson.ICONS  -> s2s "ICONS"
  |    AbsMichelson.IIF_CONS (instrs0, instrs) -> s2s "IIF_CONS" >> c2s ' ' >> c2s '(' >> showList showInstr instrs0  >> s2s ", " >>  showList showInstr instrs >> c2s ')'
  |    AbsMichelson.ISIZE  -> s2s "ISIZE"
  |    AbsMichelson.IEMPTY_SET ctyp -> s2s "IEMPTY_SET" >> c2s ' ' >> c2s '(' >> showCTyp ctyp >> c2s ')'
  |    AbsMichelson.IEMPTY_MAP (ctyp, typ) -> s2s "IEMPTY_MAP" >> c2s ' ' >> c2s '(' >> showCTyp ctyp  >> s2s ", " >>  showTyp typ >> c2s ')'
  |    AbsMichelson.IEMPTY_BIG_MAP (ctyp, typ) -> s2s "IEMPTY_BIG_MAP" >> c2s ' ' >> c2s '(' >> showCTyp ctyp  >> s2s ", " >>  showTyp typ >> c2s ')'
  |    AbsMichelson.IMAP instrs -> s2s "IMAP" >> c2s ' ' >> c2s '(' >> showList showInstr instrs >> c2s ')'
  |    AbsMichelson.IITER instrs -> s2s "IITER" >> c2s ' ' >> c2s '(' >> showList showInstr instrs >> c2s ')'
  |    AbsMichelson.IMEM  -> s2s "IMEM"
  |    AbsMichelson.IGET  -> s2s "IGET"
  |    AbsMichelson.IGET_N integer -> s2s "IGET_N" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.IUPDATE  -> s2s "IUPDATE"
  |    AbsMichelson.IUPDATE_N integer -> s2s "IUPDATE_N" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.IIF (instrs0, instrs) -> s2s "IIF" >> c2s ' ' >> c2s '(' >> showList showInstr instrs0  >> s2s ", " >>  showList showInstr instrs >> c2s ')'
  |    AbsMichelson.ILOOP instrs -> s2s "ILOOP" >> c2s ' ' >> c2s '(' >> showList showInstr instrs >> c2s ')'
  |    AbsMichelson.ILOOP_LEFT instrs -> s2s "ILOOP_LEFT" >> c2s ' ' >> c2s '(' >> showList showInstr instrs >> c2s ')'
  |    AbsMichelson.ILAMBDA (typ0, typ, instrs) -> s2s "ILAMBDA" >> c2s ' ' >> c2s '(' >> showTyp typ0  >> s2s ", " >>  showTyp typ  >> s2s ", " >>  showList showInstr instrs >> c2s ')'
  |    AbsMichelson.IEXEC  -> s2s "IEXEC"
  |    AbsMichelson.IAPPLY  -> s2s "IAPPLY"
  |    AbsMichelson.IDIP instrs -> s2s "IDIP" >> c2s ' ' >> c2s '(' >> showList showInstr instrs >> c2s ')'
  |    AbsMichelson.IDIP_N (integer, instrs) -> s2s "IDIP_N" >> c2s ' ' >> c2s '(' >> showInt integer  >> s2s ", " >>  showList showInstr instrs >> c2s ')'
  |    AbsMichelson.IFAILWITH  -> s2s "IFAILWITH"
  |    AbsMichelson.ICAST  -> s2s "ICAST"
  |    AbsMichelson.IRENAME  -> s2s "IRENAME"
  |    AbsMichelson.ICONCAT  -> s2s "ICONCAT"
  |    AbsMichelson.ISLICE  -> s2s "ISLICE"
  |    AbsMichelson.IPACK  -> s2s "IPACK"
  |    AbsMichelson.IUNPACK typ -> s2s "IUNPACK" >> c2s ' ' >> c2s '(' >> showTyp typ >> c2s ')'
  |    AbsMichelson.IADD  -> s2s "IADD"
  |    AbsMichelson.ISUB  -> s2s "ISUB"
  |    AbsMichelson.IMUL  -> s2s "IMUL"
  |    AbsMichelson.IEDIC  -> s2s "IEDIC"
  |    AbsMichelson.IABS  -> s2s "IABS"
  |    AbsMichelson.ISNAT  -> s2s "ISNAT"
  |    AbsMichelson.IINT  -> s2s "IINT"
  |    AbsMichelson.INEG  -> s2s "INEG"
  |    AbsMichelson.ILSL  -> s2s "ILSL"
  |    AbsMichelson.ILSR  -> s2s "ILSR"
  |    AbsMichelson.IOR  -> s2s "IOR"
  |    AbsMichelson.IAND  -> s2s "IAND"
  |    AbsMichelson.IXOR  -> s2s "IXOR"
  |    AbsMichelson.INOT  -> s2s "INOT"
  |    AbsMichelson.ICOMPARE  -> s2s "ICOMPARE"
  |    AbsMichelson.IEQ  -> s2s "IEQ"
  |    AbsMichelson.INEQ  -> s2s "INEQ"
  |    AbsMichelson.ILT  -> s2s "ILT"
  |    AbsMichelson.IGT  -> s2s "IGT"
  |    AbsMichelson.ILE  -> s2s "ILE"
  |    AbsMichelson.IGE  -> s2s "IGE"
  |    AbsMichelson.ISELF  -> s2s "ISELF"
  |    AbsMichelson.ISELF_ADDRESS  -> s2s "ISELF_ADDRESS"
  |    AbsMichelson.ICONTRACT typ -> s2s "ICONTRACT" >> c2s ' ' >> c2s '(' >> showTyp typ >> c2s ')'
  |    AbsMichelson.ITRANSFER_TOKENS  -> s2s "ITRANSFER_TOKENS"
  |    AbsMichelson.ISET_DELEGATE  -> s2s "ISET_DELEGATE"
  |    AbsMichelson.ICREATE_CONTRACT instrs -> s2s "ICREATE_CONTRACT" >> c2s ' ' >> c2s '(' >> showList showInstr instrs >> c2s ')'
  |    AbsMichelson.IIMPLICIT_ACCOUNT  -> s2s "IIMPLICIT_ACCOUNT"
  |    AbsMichelson.IVOTING_POWER  -> s2s "IVOTING_POWER"
  |    AbsMichelson.INOW  -> s2s "INOW"
  |    AbsMichelson.ILEVEL  -> s2s "ILEVEL"
  |    AbsMichelson.IAMOUNT  -> s2s "IAMOUNT"
  |    AbsMichelson.IBALANCE  -> s2s "IBALANCE"
  |    AbsMichelson.ICHECK_SIGNATURE  -> s2s "ICHECK_SIGNATURE"
  |    AbsMichelson.IBLAKE2B  -> s2s "IBLAKE2B"
  |    AbsMichelson.IKECCAK  -> s2s "IKECCAK"
  |    AbsMichelson.ISHA3  -> s2s "ISHA3"
  |    AbsMichelson.ISHA256  -> s2s "ISHA256"
  |    AbsMichelson.ISHA512  -> s2s "ISHA512"
  |    AbsMichelson.IHASH_KEY  -> s2s "IHASH_KEY"
  |    AbsMichelson.ISOURCE  -> s2s "ISOURCE"
  |    AbsMichelson.ISENDER  -> s2s "ISENDER"
  |    AbsMichelson.IADDRESS  -> s2s "IADDRESS"
  |    AbsMichelson.ICHAIN_ID  -> s2s "ICHAIN_ID"
  |    AbsMichelson.ITOTAL_VOTING_POWER  -> s2s "ITOTAL_VOTING_POWER"
  |    AbsMichelson.IPAIRING_CHECK  -> s2s "IPAIRING_CHECK"
  |    AbsMichelson.ISAPLING_EMPTY_STATE integer -> s2s "ISAPLING_EMPTY_STATE" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.ISAPLING_VERIFY_UPDATE  -> s2s "ISAPLING_VERIFY_UPDATE"
  |    AbsMichelson.ITICKET  -> s2s "ITICKET"
  |    AbsMichelson.IREAD_TICKET  -> s2s "IREAD_TICKET"
  |    AbsMichelson.ISPLIT_TICKET  -> s2s "ISPLIT_TICKET"
  |    AbsMichelson.IJOIN_TICKETS  -> s2s "IJOIN_TICKETS"
  |    AbsMichelson.IOPEN_CHEST  -> s2s "IOPEN_CHEST"


and showTypeSeq (e : AbsMichelson.typeSeq) : showable = match e with
       AbsMichelson.TTypSeq1 (typ0, typ) -> s2s "TTypSeq1" >> c2s ' ' >> c2s '(' >> showTyp typ0  >> s2s ", " >>  showTyp typ >> c2s ')'
  |    AbsMichelson.TTypSeq2 (typ, typeseq) -> s2s "TTypSeq2" >> c2s ' ' >> c2s '(' >> showTyp typ  >> s2s ", " >>  showTypeSeq typeseq >> c2s ')'


and showTyp (e : AbsMichelson.typ) : showable = match e with
       AbsMichelson.TCtype ctyp -> s2s "TCtype" >> c2s ' ' >> c2s '(' >> showCTyp ctyp >> c2s ')'
  |    AbsMichelson.TOption typ -> s2s "TOption" >> c2s ' ' >> c2s '(' >> showTyp typ >> c2s ')'
  |    AbsMichelson.TList typ -> s2s "TList" >> c2s ' ' >> c2s '(' >> showTyp typ >> c2s ')'
  |    AbsMichelson.TSet ctyp -> s2s "TSet" >> c2s ' ' >> c2s '(' >> showCTyp ctyp >> c2s ')'
  |    AbsMichelson.TOperation  -> s2s "TOperation"
  |    AbsMichelson.TContract typ -> s2s "TContract" >> c2s ' ' >> c2s '(' >> showTyp typ >> c2s ')'
  |    AbsMichelson.TTicket ctyp -> s2s "TTicket" >> c2s ' ' >> c2s '(' >> showCTyp ctyp >> c2s ')'
  |    AbsMichelson.TPair typeseq -> s2s "TPair" >> c2s ' ' >> c2s '(' >> showTypeSeq typeseq >> c2s ')'
  |    AbsMichelson.TOr (typ0, typ) -> s2s "TOr" >> c2s ' ' >> c2s '(' >> showTyp typ0  >> s2s ", " >>  showTyp typ >> c2s ')'
  |    AbsMichelson.TLambda (typ0, typ) -> s2s "TLambda" >> c2s ' ' >> c2s '(' >> showTyp typ0  >> s2s ", " >>  showTyp typ >> c2s ')'
  |    AbsMichelson.TMap (ctyp, typ) -> s2s "TMap" >> c2s ' ' >> c2s '(' >> showCTyp ctyp  >> s2s ", " >>  showTyp typ >> c2s ')'
  |    AbsMichelson.TBig_map (ctyp, typ) -> s2s "TBig_map" >> c2s ' ' >> c2s '(' >> showCTyp ctyp  >> s2s ", " >>  showTyp typ >> c2s ')'
  |    AbsMichelson.TBls_g1  -> s2s "TBls_g1"
  |    AbsMichelson.TBls_g2  -> s2s "TBls_g2"
  |    AbsMichelson.TBls_fr  -> s2s "TBls_fr"
  |    AbsMichelson.TSapling_transaction integer -> s2s "TSapling_transaction" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.TSapling_state integer -> s2s "TSapling_state" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'
  |    AbsMichelson.TChest  -> s2s "TChest"
  |    AbsMichelson.TChest_key  -> s2s "TChest_key"


and showCTypeSeq (e : AbsMichelson.cTypeSeq) : showable = match e with
       AbsMichelson.CTypSeq1 (ctyp0, ctyp) -> s2s "CTypSeq1" >> c2s ' ' >> c2s '(' >> showCTyp ctyp0  >> s2s ", " >>  showCTyp ctyp >> c2s ')'
  |    AbsMichelson.CTypSeq2 (ctyp, ctypeseq) -> s2s "CTypSeq2" >> c2s ' ' >> c2s '(' >> showCTyp ctyp  >> s2s ", " >>  showCTypeSeq ctypeseq >> c2s ')'


and showCTyp (e : AbsMichelson.cTyp) : showable = match e with
       AbsMichelson.CUnit  -> s2s "CUnit"
  |    AbsMichelson.CNever  -> s2s "CNever"
  |    AbsMichelson.CBool  -> s2s "CBool"
  |    AbsMichelson.CInt  -> s2s "CInt"
  |    AbsMichelson.CNat  -> s2s "CNat"
  |    AbsMichelson.CString  -> s2s "CString"
  |    AbsMichelson.CChain_id  -> s2s "CChain_id"
  |    AbsMichelson.CBytes  -> s2s "CBytes"
  |    AbsMichelson.CMutez  -> s2s "CMutez"
  |    AbsMichelson.CKey_hash  -> s2s "CKey_hash"
  |    AbsMichelson.CKey  -> s2s "CKey"
  |    AbsMichelson.CSignature  -> s2s "CSignature"
  |    AbsMichelson.CTimestamp  -> s2s "CTimestamp"
  |    AbsMichelson.CAddress  -> s2s "CAddress"
  |    AbsMichelson.COption ctyp -> s2s "COption" >> c2s ' ' >> c2s '(' >> showCTyp ctyp >> c2s ')'
  |    AbsMichelson.COr (ctyp0, ctyp) -> s2s "COr" >> c2s ' ' >> c2s '(' >> showCTyp ctyp0  >> s2s ", " >>  showCTyp ctyp >> c2s ')'
  |    AbsMichelson.CPair ctypeseq -> s2s "CPair" >> c2s ' ' >> c2s '(' >> showCTypeSeq ctypeseq >> c2s ')'



