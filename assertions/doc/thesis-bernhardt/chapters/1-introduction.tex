\chapter{Introduction}\label{chap:introduction}
Headed by Bitcoin in 2009, ``cryptocurrencies have emerged as the first generation of blockchain technology'' \cite{alharby_blockchain_2017}. However, their transactions are mostly limited to simple monetary transactions or registration of assets or ownerships \cite{alharby_blockchain_2017}. More recent blockchains, considered as the second generation \cite{alharby_blockchain_2017}, aim to provide a platform for building more sophisticated and complex applications on top of the technology. These are built with smart contracts, programs written in Turing-complete languages. Running a smart contract, though, generates costs proportional to the amount and complexity of computations, as well as its storage usage \cite{alharby_blockchain_2017}. These fees, often measured in a unit called ``gas'', have to be paid for by the user in order to compensate the miners for their efforts \cite{chen_under-optimized_2020}. This creates a powerful incentive to keep smart contracts simple and efficient, while in reality, meaningful applications still might need to perform some resource intensive computations. Not only can such applications generate unsustainable costs when executed on the blockchain, but may also reach gas limits imposed by the blockchain's protocol. \\
In order to avoid these costs and restrictions, such an application could perform some computations outside of the blockchain context (i.e., off-chain) and only submit the results to a smart contract as an input parameter for further processing or recording \cite{thiemann_2020}. By trusting that the submitted results are correct, this approach raises both safety and security issues. Invalid results can be submitted unintentionally as a result of a wrong computation, or a third party may pass them intentionally to cause harm or take advantage. Consequently, submitted parameters should be checked for assumed properties before the smart contract is executed. Although in many cases, verifying a solution takes less time than computing the result itself (cf. NP-hard problems \cite{nph_problems} or sorting algorithms \cite{review_sorting}\cite{cpp_issorted}), the generated costs for checking the validity increase with the size of the input. \\
Consider, for instance, the following smart contract:
\begin{lstlisting}[caption=Smart contract expecting a prime number \cite{thiemann_2020}, numbers=none, language=Solidity, label=lst:prime]
contract Example {
	function ( int p ) public {
	// assume p is prime
	...
	}
}
\end{lstlisting}
The assumption, that the given integer $p$ is a prime, can be expressed as an explicit assertion in predicate logic \cite{thiemann_2020}: 
\begin{equation}\label{eq:prime}
    (\forall n) (2 \le n \le \sqrt{p}) \Rightarrow (p \% n) \neq 0
\end{equation}
To check whether this property holds for $p$, the contract has to execute a loop. Assuming computing the body of the loop takes constant time, this test has a time complexity of $\mathcal{O}(\sqrt{p})$ and therefore generates costs linear in $\sqrt{p}$ on top of the cost for executing the actual contract. Thus, a mechanism is required that allows the smart contract to make use of the result computed by an off-chain source, without having to check its validity locally with scaling costs.

\section{A distributed approach for assertion checking}
A more efficient way to solve the issue at hand could be to engage the validators of the blockchain into a distributed effort to find a counterexample. If no counterexample could be found by any validator, the assumption is considered to be valid and the execution of the contract may resume. On the other hand, an identified counterexample is made public on the peer-to-peer network and thus cancels the contract execution (i.e., the transaction fails). \\
In order to find a counterexample, the formula in \eqref{eq:prime} has to be transformed to its negation:
\begin{equation}\label{eq:prime_neg}
	(\exists n) (2 \le n \le \sqrt{p}) \wedge (p \% n) = 0
\end{equation}

Each validator then checks the inverse property $(p \% n) = 0$ point-wise for some random $n$ within the given boundaries $2 \le n \le \sqrt{p}$. If a validator finds a counterexample, i.e., a value for $n$ where the reminder is $0$, it posts an objection to the network. For each involved validator, the constant cost of generating one random number and calculating one division have to be paid, which is independent from $p$. \\
However, distributed assertion checking is not only applicable for parameters or properties of dynamic size. Another example is a contract that expects an array of integers sorted in ascending order: 

\begin{lstlisting}[caption=Smart contract expecting a sorted array \cite{thiemann_2020}, numbers=none, language=Solidity, label=lst:sorted]
contract Sorted {
  function find ( int [50] a , int v ) public {
    // assume a is sorted
  }
}
\end{lstlisting}
 
The assumption that the list is sorted, expressed in predicate logic, is
\begin{equation}\label{eq:sorted}
	(\forall n) (0 \leq n < |a| - 1) \Rightarrow a[n] \leq a[n+1]
\end{equation}

Even though the assertion can be checked in a loop in $\mathcal{O}(1)$, the constant factor is not negligible. Hence, the same approach can be applied here by considering the negation and have the validators search for counterexamples, checking random values for $n$:
 
\begin{equation}\label{eq:sorted_neg}
	(\exists n) (0 \leq n < |a| - 1) \wedge a[n] > a[n+1]
\end{equation}

Since the validators sample the domain randomly, the absence of a counterexample doesn't prove that the assumption is correct; the validation is only probabilistic and the reliability depends on the number of validators in the network. This corresponds to the principle of Bloom filters, where a queried element is either ``certainly not'' or ``possibly'' a member of a defined set \cite{blustein_bloom_2002}. In the case of assertion checking, we consider the assumption to be either definitely not or possibly valid. The probability of false positives in Bloom filters is an approximate function of the filter size and the number of inserted elements, supposing an optimal number of hash functions have been implemented. Tuning these parameters is a trade-off between making the filter more reliable, i.e., lowering its error rate, and space efficiency \cite{blustein_bloom_2002}. The same applies, with some reservations, to distributed assertion checking: less samples keep the gas consumption to a minimum, whereas more samples increase the probability that an existing counterexample is found. Referring to the example of sorted lists,  the probability of false positives depends on the size of the list $a$ and the number of validators $m$.

The importance of the former parameter becomes apparent when considering the worst case scenario of the same example. Assuming the array is unsorted at exactly one position - the probability that the each of the $m$ validators independently check this position is $\frac{1}{|a|}$, whereas the probability of all of them checking any other position $\frac{|a|-1}{|a|}$. If the random generator chooses each value for $n$ independently from a uniform distribution, the probability that the counterexample is not detected by any validator converges to 0 if the number of validators approaches infinity \cite{thiemann_2020}:
\begin{equation}\label{eq:limes_validators}
	\lim_{m\to\infty} \left(\frac{|a|-1}{|a|}\right)^m = 0
\end{equation}

\section{Objective}
This thesis proposes the portrayed approach of a distributed assertion checking scheme in order to make more efficent use of off-chain resources. The realisation of such assertions consists of two components - the off-chain design and implementation of supporting infrastructure, as well as the extension of the smart contract language and amendment of the blockchain protocol, s.t. these assertions are triggered and handled correctly by the network. The focus of this thesis is put primarily on the off-chain component and the development of a toolchain that transforms and translates assertions to executable code for the target platform, but elaborates on the protocol design where necessary. To this end, a first approximation of a set of formulas amenable for distributed assertion checking is defined, special cases are identified and, if necessary, excluded. While the off-chain design and toolchain should be partially applicable to any blockchain supporting smart contracts, the case example for the protocol-specific parts of the design targets the Tezos blockchain and its built-in contract language Michelson. On the basis of the chosen design, the thesis evaluates the efficiency of the approach in terms of costs incurred by checking a formula on Tezos, and discusses if, and under which conditions, these costs are competitive versus a local approach.

\section{Structure overview}
The structure of this thesis is as follows: in the first instance, \chapref{chap:use_cases} defines a set of logical formulas that describe parameter properties and are suitable for distributed assertion checking. Given this set, it demonstrates various practical use-cases for such properties and formalizes the costs of checking them locally, s.t. they can later be referenced to assess the efficiency of the distributed approach. \chapref{chap:offline} describes the generic aspects of the off-chain design and infrastructure, i.a. the definition of a syntax to express assertions on top of the logical formulas and how they are transformed to code that checks for counterexamples. Additionally, it analyses the effectiveness of the statistical validation for a given input and provides a formula to compute the lower bound of validators necessary to obtain a reliable result. Subsequently, \chapref{chap:offline_tezos} gives a brief introduction to Tezos, before it covers target specific aspects of the off-chain design. Besides identifying necessary extensions to Michelson's instruction set and virtual machine, it explores various orchestration strategies between assertion and contract code. The chapter closes with a cost analysis of distributed assertion checking on Tezos with the chosen orchestration strategy. In conclusion, the last chapter recaps the achieved results, 
addresses any open questions or issues and provides an outlook on upcoming work on this topic.