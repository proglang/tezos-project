\chapter{Introduction}\label{chap:introduction}
Headed by Bitcoin in 2009 \cite{bitcoin-whitepaper}, the first generation of blockchain technology emerged in form of cryptocurrencies. However, their transactions are mostly limited to simple monetary transactions or registration of assets or ownerships \cite{alharby_blockchain_2017}. More recent blockchains, considered as the second generation, aim to provide a platform for building more sophisticated and complex applications on top of the technology. Some prominent examples for such blockchains are Ethereum \cite{eth-whitepaper}, Tezos \cite{goodman_tezos_2014} or Cardano \cite{cardano_essay}, which plans to introduce smart contracts in an update this year \cite{cardano_alonzo}. Blockchain-based applications are built with smart contracts, programs written in Turing-complete languages. Running a smart contract generates costs proportional to the amount and complexity of computations, as well as its storage usage \cite{alharby_blockchain_2017}. These fees, often measured in a unit called ``gas'', have to be paid for by the user in order to compensate the miners for their efforts \cite{narayanan_bitcoin}. This creates a powerful incentive to keep smart contracts simple and efficient. In reality, however, meaningful applications still might need to perform resource intensive computations or store larger amounts of data. Not only can such applications generate unsustainable costs when executed on the blockchain, but they may also reach gas limits imposed by the blockchain's protocol. \\
In order to avoid these costs and restrictions, such an application could perform some computations outside of the blockchain context (i.e., off-chain) and only submit the results to a smart contract as an input parameter for further processing or recording. By trusting that the submitted results are correct, this approach raises both safety and security issues. Invalid results can be submitted unintentionally as a result of a wrong computation, or a third party may pass them intentionally to cause harm or capitalize on it. Consequently, submitted parameters should be validated before the smart contract is executed. Although in many cases, verifying a solution takes less time than computing the result itself (cf. NP-hard problems \cite{nph_problems} or sorting algorithms \cite{review_sorting}\cite{cpp_issorted}), the generated costs for checking the validity increase with the size of the input. \\
Consider the smart contract \texttt{Example}, which is shown in \lstref{lst:prime} and features a function \texttt{f}. The function takes an input value \texttt{p} of type integer and should make use of the assumption that \texttt{p} is a prime number.
\begin{lstlisting}[caption=Smart contract with a function expecting a prime number \cite{thiemann_2020}, numbers=none, language=Solidity, label=lst:prime]
contract Example {
	function f ( int p ) public {
	// assume p is prime
	...
	}
}
\end{lstlisting}
The assumption ``$p$ is a prime number'' can be expressed with the following explicit assertion in predicate logic: 
\begin{equation}\label{eq:prime}
    (\forall n) (2 \le n \le \sqrt{p}) \Rightarrow (p \% n) \neq 0
\end{equation}
To check whether this property holds for $p$, the contract has to execute a loop over the range $[2, \sqrt{p}]$. Assuming that computing the body of the loop takes constant time, this test has a time complexity of $\mathcal{O}(\sqrt{p})$ and therefore generates costs linear in $\sqrt{p}$ on top of the cost for executing the actual contract. Thus, a mechanism is required that allows the smart contract to make use of the result computed by an off-chain source, without having to check its validity locally with scaling costs.

\section{A distributed approach for assertion checking}
A more efficient way to solve the issue at hand could be to engage the validators of the blockchain into a distributed effort to find a counterexample. If no counterexample could be found by any validator, the assumption is considered to be valid and the execution of the contract may resume. On the other hand, an identified counterexample is made public on the peer-to-peer network and thus cancels the contract execution (i.e., the transaction fails). \\
In order to find a counterexample, the formula in \eqref{eq:prime} has to be transformed to its negation:
\begin{equation}\label{eq:prime_neg}
	(\exists n) (2 \le n \le \sqrt{p}) \wedge (p \% n) = 0
\end{equation}

Each validator then checks the inverse property $(p \% n) = 0$ point-wise for some random $n$ within the given boundaries $2 \le n \le \sqrt{p}$. If a validator finds a counterexample, i.e., a value for $n$ where the reminder is $0$, it posts a veto to the network. For each involved validator, the constant cost of generating one random number and calculating one division have to be paid, which is independent from $p$. \\
However, distributed assertion checking is not only applicable for parameters or properties of dynamic size. Function \texttt{find} of contract \texttt{Sorted}, shown in \lstref{lst:sorted}, expects a statically sized array of integers and a single integer value. In order to find the value \texttt{v} in \texttt{a} more efficiently, the array is assumed to be sorted. 

\begin{lstlisting}[caption=Smart contract expecting a sorted array \cite{thiemann_2020}, numbers=none, language=Solidity, label=lst:sorted]
contract Sorted {
  function find ( int [50] a , int v ) public {
    // assume a is sorted
    ...
  }
}
\end{lstlisting}

The explicit assertion of this assumption (in the variant of an ascending sorting) can be expressed as follows in predicate logic:
\begin{equation}\label{eq:sorted}
	(\forall n) (0 \leq n < |a| - 1) \Rightarrow a[n] \leq a[n+1]
\end{equation}

Even though the assertion can be checked in a loop in $\mathcal{O}(1)$, the constant factor is not negligible. Again, by considering the negation, the validators can be engaged to search for counterexamples by checking random values for $n$:
 
\begin{equation}\label{eq:sorted_neg}
	(\exists n) (0 \leq n < |a| - 1) \wedge a[n] > a[n+1]
\end{equation}

Since the validators sample the domain randomly, the absence of a counterexample doesn't prove that the assumption is correct; the validation is only probabilistic and the reliability depends on the number of validators in the network. This corresponds to the principle of Bloom filters, where a queried element is either ``certainly not'' or ``possibly'' a member of a defined set \cite{blustein_bloom_2002}. In the case of assertion checking, we consider the assumption to be either definitely not or possibly valid. The probability of false positives in Bloom filters is an approximate function of the filter size and the number of inserted elements, supposing an optimal number of hash functions have been implemented. Tuning these parameters is a trade-off between making the filter more reliable, i.e., lowering its error rate, and space efficiency \cite{blustein_bloom_2002}. The same applies, with some reservations, to distributed assertion checking: fewer samples keep the gas consumption (and thus cost) to a minimum, whereas more samples reduce the probability of accepting an invalid result. Referring to the example of sorted lists, the probability of false positives depends on the size of the list $a$ and the number of validators $m$.

The importance of the former parameter becomes apparent when considering the worst case scenario of the same example. Assuming the array is unsorted at exactly one position - the probability that the each of the $m$ validators independently check this position is $\frac{1}{|a|}$, whereas the probability of all of them checking any other position $\frac{|a|-1}{|a|}$. If the random generator chooses each value for $n$ independently from a uniform distribution, the probability that the counterexample is not detected by any validator converges to 0 if the number of validators approaches infinity \cite{thiemann_2020}:
\begin{equation}\label{eq:limes_validators}
	\lim_{m\to\infty} \left(\frac{|a|-1}{|a|}\right)^m = 0
\end{equation}

\section{Objective}
This thesis proposes a model for the portrayed approach of a distributed assertion checking scheme, in order to make more efficient use of off-chain computations. In this model, results of such computations are validated on-chain by the validators of the network. In order to do so, they invoke assertion smart contracts, which point-wise check the validity of certain properties. When claiming an assertion failure, a validator publishes a counterexample to be scrutinized by the other validators. If they come to a consensus about the invalidity, the result is rejected. Provided that the assertion is cheaper than the computation itself, the purpose of this proposal is not only to reduce financial costs for the users, but also to overcome limitations in scalability imposed by gas limits.

The realisation of such assertions consists of an off-chain and an on-chain component. The off-chain component is a toolchain to specify, integrate and generate assertion contracts that can be deployed to the blockchain. This includes the definition of a domain-specific language, which allows developers to specify assertions for each entrypoint of a Smart Contract. The on-chain component, on the other hand, consists of an amendment of the blockchain protocol. This amendment includes an extension of the Smart Contract language with instructions generating random values in a non-deterministic way, a transaction type that can trigger the distributed execution of assertions, and the implementation of a consensus mechanism for counterexamples. 

The focus of this thesis is put primarily on the off-chain component, but it elaborates on the protocol design where necessary.  Even though efforts were made to keep the design as generic and re-usable as possible, the implementation targets the Tezos \cite{goodman_tezos_2014} blockchain and its built-in contract language Michelson \cite{michelson_ref}. On the basis of the design and implementation for Tezos, the thesis evaluates the efficiency and incurred costs of this approach compared to a centralized assertion approach.

\section{Related work}
Outsourcing computations or storage to off-chain resources, in order to improve the scalability of blockchains, has been the topic of several research papers and projects. They provide diverse solutions for different applications and use-cases. Eberhardt and Tai \cite{eberhardt_offonchain} give insights gained from a set of blockchain projects focusing on off-chaining. They provide five patterns to move either computations or storage off the chain without compromising the benefits of blockchains. The ``Delegated Computation Pattern'' outsources computations, which are too complex for on-chain execution, to an untrusted third party and only verifies the proof of correct execution on-chain. The proposed approach of a distributed assertion checking scheme can therefore be considered as a possible implementation of this pattern.

ZoKrates \cite{eberhardt_zokrates_2018} proposes a processing model for the same pattern, which employs non-interactive zero-knowledge proofs (zkSNARKs) to verify the results on-chain. When such proofs are supplied together with the results, the correctness can be validated fast and cheaply by the miners and nodes of the network. They additionally provide a toolbox and a domain-specific language to specify off-chain computations, generate respective proofs and export Smart Contracts verifying these proofs.

The TrueBit \cite{teutsch_truebit} project provides another means for off-chaining computations on the Ethereum blockchain. It outsources computations to a pool of \textit{Solvers}, whose solutions are either verified or challenged by a pool of \textit{Verifiers}, or \textit{Challengers}. The protocol uses economic incentives to encourage active participation of all roles and only engages the miners as \textit{Judges} in case of a dispute between a Solver and a Challenger. 

\section{Structure overview}
The structure of this thesis is as follows: in the first instance, \chapref{chap:use_cases} defines a set of logical formulas suitable for the proposed scheme of distributed assertion checking. Given this set, it demonstrates various practical use-cases  and formalizes the costs of checking them locally, s.t. they can later be used as a benchmark to assess the efficiency of the distributed approach. \chapref{chap:offline} describes the frontend of the toolchain and generic aspects of the off-chain design. As a premise for the toolchain backend, \chapref{chap:prob_model} defines the probabilistic model of the scheme and analyses the effectiveness of the probabilistic validation. After providing a brief introduction to the Tezos blockchain and its Smart Contract language Michelson, \chapref{chap:offline_tezos} covers target specific aspects of the off-chain design and the implementation of the toolchain backend. The chapter closes with an evaluation of the proposed scheme based with regard to Tezos as the target platform. In conclusion, the last chapter recaps the achieved results, addresses open questions or issues and provides an outlook on upcoming work on this topic.