\chapter{Introduction}\label{chap:introduction}
Headed by Bitcoin in 2009, ``cryptocurrencies have emerged as the first generation of blockchain technology'' \cite{alharby_blockchain_2017}. However, their transactions are mostly limited to simple monetary transactions or registration of assets or ownerships \cite{alharby_blockchain_2017}. More recent blockchains, considered as the second generation \cite{alharby_blockchain_2017}, aim to provide a platform for building more sophisticated and complex applications on top of the technology. These are built with smart contracts, programs written in Turing-complete languages. Running a smart contract, though, generates costs proportional to the amount and complexity of computations, as well as its storage usage \cite{alharby_blockchain_2017}. These fees, often measured in a unit called ``gas'', have to be paid for by the user in order to compensate the miners for their efforts \cite{chen_under-optimized_2020}. This creates a powerful incentive to keep smart contracts simple and efficient, while in effect, meaningful applications still might need to perform some resource intensive computations. Not only can such applications generate unsustainable costs when executed on the blockchain, but they may also reach gas limits imposed by the blockchain's protocol. \\
In order to avoid these costs and restrictions, such an application could perform some computations outside of the blockchain context (i.e., off-chain) and only submit the results to a smart contract as an input parameter for further processing or recording \cite{thiemann_2020}. By trusting that the submitted results are correct, this approach raises both safety and security issues. Invalid results can be submitted unintentionally as a result of a wrong computation, or a third party may pass them intentionally to cause harm or take advantage. Consequently, submitted parameters should be checked for assumed properties before the smart contract is executed. Although in many cases, verifying a solution takes less time than computing the result itself\footnote{cf. NP-hard problems \cite{nph_problems}, sorting algorithms \cite{review_sorting}\cite{cpp_issorted}, etc.}, the generated costs for checking the validity increase with the size of the input. \\
Consider, for instance, the following contract:
\begin{lstlisting}[caption=Smart contract expecting a prime number \cite{thiemann_2020}, numbers=none, language=Solidity, label=lst:prime]
contract Example {
	function ( int p ) public {
	// assume p is prime
	...
	}
}
\end{lstlisting}
The assumption, that the given integer $p$ is a prime, can be expressed as an explicit assertion in predicate logic \cite{thiemann_2020}: 
\begin{equation}\label{eq:prime}
    (\forall n) (2 \le n \le \sqrt{p}) \Rightarrow (p \% n) \neq 0
\end{equation}
To check whether this property holds for $p$, the contract has to execute a loop. Assuming computing the body of the loop takes constant time, this test has a time complexity of $\mathcal{O}(\sqrt{p})$ and therefore generates costs linear in $\sqrt{p}$ on top of the cost for executing the actual contract. Thus, a mechanism is required that allows the smart contract to make use of the result computed by an off-chain source, without having to check its validity locally with scaling costs.

\section{A distributed approach for assertion checking}
A more efficient way to solve the issue at hand could be to engage the validators of the blockchain into a distributed effort to find a counterexample. If no counterexample could be found by any validator, the assumption is considered to be valid and the execution of the contract may resume. On the other hand, an identified counterexample is made public on the peer-to-peer network and thus cancels the contract execution (i.e., the transaction fails). \\
In order to find a counterexample, the formula in \eqref{eq:prime} has to be transformed to its negation:
\begin{equation}\label{eq:prime_neg}
	(\exists n) (2 \le n \le \sqrt{p}) \wedge (p \% n) = 0
\end{equation}

Each validator then checks the inverse property $(p \% n) = 0$ point-wise for some random $n$ within the given boundaries $2 \le n \le \sqrt{p}$. If a validator finds a counterexample, i.e., a value for $n$ where the reminder is $0$, it posts an objection to the network. For each involved validator, the constant cost of generating one random number and calculating one division have to be paid, which is independent from $p$. \\
However, distributed assertion checking is not only applicable for parameters or properties of dynamic size. Another example given in \cite{thiemann_2020} shows a contract that expects an array of integers sorted in ascending order: 

\begin{lstlisting}[caption=Smart contract expecting a sorted array, numbers=none, language=Solidity, label=lst:sorted]
contract Sorted {
  function find ( int [50] a , int v ) public {
    // assume a is sorted
  }
}
\end{lstlisting}
 
The assumption that the list is sorted, expressed in predicate logic, is
\begin{equation}\label{eq:sorted}
	(\forall n) (0 \leq n < |a| - 1) \Rightarrow a[n] \leq a[n+1]
\end{equation}

Even though the assertion can be checked in a loop in $\mathcal{O}(1)$, the constant factor is not negligible. Hence, the same approach can be applied here by considering the negation and have the validators search for counterexamples, checking random values for $n$:
 
\begin{equation}\label{eq:sorted_neg}
	(\exists n) (0 \leq n < |a| - 1) \wedge a[n] > a[n+1]
\end{equation}

Since the validators sample the domain randomly, the absence of a counterexample doesn't prove that the assumption is correct; the validation is only probabilistic and the reliability depends on the number of validators in the network. This corresponds to the principle of Bloom filters, where a queried element is either ``certainly not'' or ``possibly'' a member of a defined set \cite{blustein_bloom_2002}. In the case of assertion checking, we consider the assumption to be either definitely not or possibly valid. The probability of false positives in Bloom filters is an approximate function of the filter size and the number of inserted elements, supposing an optimal number of hash functions have been implemented. Tuning these parameters is a trade-off between making the filter more reliable, i.e., lowering its error rate, and space efficiency \cite{blustein_bloom_2002}. The same applies, with some reservations, to distributed assertion checking: less samples keep the gas consumption to a minimum, whereas more samples increase the probability that an existing counterexample is found. Referring to the example of sorted lists,  the probability of false positives depends on the size of the list $a$ and the number of validators $m$.\\
The importance of the former parameter becomes obvious when looking at the worst case scenario of the same example. Assume the array is unsorted at exactly one position - the probability that the each of the $m$ validators independently check this position is $\frac{1}{|a|}$, while all of them checking any other position $\frac{|a|-1}{|a|}$. If the random generator chooses each value for $n$ independently from a uniform distribution, the probability that the counterexample is not detected by any validator converges to 0 if the number of validators approaches infinity \cite{thiemann_2020}:
\begin{equation}\label{eq:limes_validators}
	\lim_{m\to\infty} \left(\frac{|a|-1}{|a|}\right)^m = 0
\end{equation}

\section{Objective}
This thesis conducts research into the feasibility and performance of the proposed approach and explores possible designs for the implementation of both the necessary off-chain infrastructure and the amendment of the blockchain protocol. To this end, a first approximation of a set of formulas amenable for distributed assertion checking is defined, special cases are identified and, if necessary, excluded. While parts of the offline design and infrastructure should be, in parts, applicable to any blockchain supporting smart contracts, the case example for the protocol-specific parts of the design target the Tezos blockchain and its built-in contract language Michelson. On the basis of the achieved results, the efficiency of the approach is ultimately assessed.

\section{Structure overview}
\draft{Finish when structure \& chapters finalised.}
\begin{itemize}
\item Assessment of use cases for this kind of assertion checking (Chapter 2)
	\begin{itemize}
	\item defines a set of logical formula
	\item gives some useful examples
	\item cost analysis for checking them normally
	\end{itemize}
\item Generic Offline Design (Chapter 3)
	\begin{itemize}
	\item definition of language/syntax to express assertions over given set of logical formulas
	\item formalizes the transformation
	\item describes frontend of pipeline
	\item analyses accuracy of this approach
	\end{itemize}
\item Tezos-specific Offline Design (Chapter 4)
	\begin{itemize}
	\item introduction/Overview to Tezos
	\item necessary extensions to Michelson's instruction set \& evaluator
	\item description of the pipeline backend
	\item Cost analysis \& accuracy on Tezos
	\end{itemize}
\item Conclusion \& outlook
	\begin{itemize}
	\item Next steps/ToDos for development; open issues
	\item Evaluation of costs -> is this approach promising?
	\item Alternatives? E.g. Refer to TrueBit
	\end{itemize}
\end{itemize}
