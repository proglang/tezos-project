\chapter{Introduction}\label{chap:introduction}
Each execution of a blockchain-based Smart Contract in a gas-instrumented virtual machine generates costs proportional to the amount and complexity of computations and the  memory consumption \cite{goodman_tezos_2014}\cite{wood_ethereum_2021}. These fees, often calculated in gas, have to be paid for by the sender of the transaction and thus provides a powerful incentive to keep  smart contracts simple. However, in reality meaningful applications might need to perform some resource intensive computations at some point, which would be too expensive to execute inside the blockchain's virtual machine. Moreover, some blockchains impose a hard cap of how much gas can be consumed in one transaction, limiting the amount of operations that can be executed \cite{goodman_tezos_2014}.\\
In order to avoid these costs and restrictions, an application could perform some computations outside of the blockchain context (i.e., off-chain) and only submit the results to a smart contract as input parameter for further processing or to store it on the chain. This approach raises another problem though - trusting that the submitted results are correct poses a safety as well as a security risk. Invalid results can be submitted unintentionally, if the computation is faulty, or a third party may pass them intentionally to cause harm or take advantage. Consequently, submitted parameters need to be checked for specified properties before the smart contract is executed. Although in many cases, verification is less expensive than computing the result itself, the generated costs for checking the validity increase with the size of the problem or input, ultimately becoming too expensive. \\
Consider, for instance, the following contract from \cite{thiemann_2020} that expects a prime number: \todo{State programming language?!}
\begin{lstlisting}[caption=Smart contract expecting a prime number, numbers=none, language=Solidity, label=lst:prime]
contract Example {
	function ( int p ) public {
	// assume p is prime
	...
	}
}
\end{lstlisting}

The assumption that the given integer $p$ is a prime can be expressed as an explicit assertion in predicate logic: 
\begin{equation}\label{eq:prime}
    (\forall n) (2 \le n \le \sqrt{p}) \Rightarrow (p \% n) \neq 0
\end{equation}

Checking if this property holds requires the contract to execute a loop in $\mathcal{O}(\sqrt{p})$ time and therefore generate costs linear in $\sqrt{p}$ on top of the actual contract execution, assuming computing the body of the loop takes constant time.\\
Thus it appears that we need a mechanism that allows the smart contract to make use of the computed result from an off-chain source without having to validate its validity locally with scaling costs.

\section{A distributed approach for assertion checking}
A more efficient way to solve the issue at hand is to engage the validators of the blockchain into a distributed effort to find a counterexample that disproves an assumption. If no counterexample could be found by any validator, the assumption is considered to be valid and the execution of the contract may resume. On the other hand, an identified counterexample is made public on the peer-to-peer network and thus cancels the contract execution (i.e., the transaction fails). \\
In order to find counterexamples of an assertion, the formula in \ref{eq:prime} has to be transformed to its negation:
\begin{equation}\label{eq:prime_neg}
	(\exists n) (2 \le n \le \sqrt{p}) \wedge (p \% n) = 0
\end{equation}

Each validator then checks the inverse property $(p \% n) = 0$ point-wise for some random $n$ within the given boundaries $2 \le n \le \sqrt{p}$. If a validator finds a counterexample, i.e., a value for $n$ where the reminder is $0$, it posts an objection to the network. For each involved validator the constant cost of generating one random number and calculating one division have to be paid, which is independent from $p$. \\
However, distributed assertion checking is not only applicable for parameters or properties of dynamic size. Another example given in \cite{thiemann_2020} shows a contract that expects an array of integers sorted in ascending order: 

\begin{lstlisting}[caption=Smart Contract expecting a sorted array, numbers=none, language=Solidity, label=lst:sorted]
contract Sorted {
  function find ( int [50] a , int v ) public {
    // assume a is sorted
  }
}
\end{lstlisting}
 
The assumption that the list is sorted, expressed in predicate logic, is
\begin{equation}\label{eq:sorted}
	(\forall n) (0 \leq n < |a| - 1) \Rightarrow a[n] \leq a[n+1]
\end{equation}

Even though the assertion can be checked in a loop in $\mathcal{O}(1)$, the constant factor is not negligible and can generate unreasonable costs. Hence, we consider the negation again and ask the validators to search for counterexamples by checking a random value for $n$:
 
\begin{equation}\label{eq:sorted_neg}
	(\exists n) (0 \leq n < |a| - 1) \wedge a[n] > a[n+1]
\end{equation}

Since the validators do random sampling, none of them finding a counterexample doesn't prove that the assumption is correct - the validation is only probabilistic and the reliability depends on the number of validators in the network. This corresponds to the principle of Bloom filters, where a queried element is either certainly not or possibly in a defined set \cite{blustein_bloom_2002}. In the case of assertion checking, it's the assumption that is either definitely not or maybe valid. The probability of false positives in Bloom filters is an approximate function of the filter size and the number of inserted elements, supposing an optimal number of hash functions have been implemented. Tuning these parameters is a trade-off between making the filter more reliable, that is lowering its error rate, and space efficiency \cite{blustein_bloom_2002}. The same applies, with some reservations, to distributed assertion checking: less samples keep the costs to a minimum, whereas more samples increase the probability that, if it exists, a counterexample is found. In the last example, the probability of false positives depends on the size of $a$ and the number of validators.\\
The importance of the former parameter becomes obvious when looking at the worst case scenario of the same example. Assume the array is unsorted at exactly one position - the probability that the each of the $m$ validators independently check this position is given by $\frac{1}{|a|}$, and any other position by $\frac{|a|-1}{|a|}$. If the random generator chooses each value for $n$ independently from a uniform distribution, the probability that the counterexample is not detected by any validator converges to 0 if the number of validators approach infinity \cite{thiemann_2020}
\begin{equation}\label{eq:limes_validators}
	\lim_{m\to\infty} \left(\frac{|a|-1}{|a|}\right)^m = 0
\end{equation}

\move{maybe too detailed? move to efficiency section}

\todo{Ueberleitung}


\section{Structure overview}
which formulas are amendable?
costs of testing them?

This thesis assesses uses cases for this kind of testing, defines a language/syntax to express properties/assumptions like in the examples and explores how the mechanism can be implemented, using the Tezos blockchain and its smart contract language as platform/example. 
How the mechanism could/would be implemented in the Tezos blockchain ...
which extensions to the Michelson language and the Tezos protocol are necessary
-> roadmap welche schritte es gibt
	- language (assertion syntax)
	- pipeline -> compile to Michelson
	- extend Michelson language/interpreter etc.
	- how does protocol have to be adapted
	
The effectiveness of this approach is analyzed in detail (how many samples are necessary to reach a certain confidence level? which levels are appropriate?)

Analyze the costs that are incurred by checking a formula with this approach; compare it with non-distributed approach.
Both effectiveness \& cost model are used to evaluate this approach. Some alternatives are discussed. (here or in final chapter?)

Finally, it gives an outlook what still needs to be done, what can be improved. It summarizes the results so far and evaluates.





