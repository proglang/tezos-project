\chapter{Toolchain Implementation - Frontend}\label{chap:offline}
The purpose of the toolchain is to support the proposed model from specifying assertions for Smart Contracts, transforming them to their negation to generating assertion Smart Contracts that can be invoked by the validators. As determined in \secref{sec:restrict}, the current version of the toolchain only supports the processing of assertions featuring universal quantification. The toolchain was developed in the programming language OCaml \cite{ocaml_docs} --- the code is available in a GitHub\footnote{\url{https://github.com/proglang/thesis-distributed-assertion-checking}\todo{commit}} repository of the Chair of Programming Languages.

As an overview, \figref{fig:pipeline_frontend} depicts all stages of the processing pipeline implemented by the toolchain. The colourized stages highlight the frontend, which was designed to be as generic as possible, s.t. it can be used (or extended) to support any target blockchain. For the target-specific processing, the intermediate result of the frontend is passed to the respective backends via a public interface.

\begin{figure}[h]
\includegraphics[width=\linewidth]{figures/3-offline/pipeline_frontend}
\caption{The stages of the generic frontend of the compilation pipeline}
\label{fig:pipeline_frontend}
\end{figure}

First, developers can specify assertions in a domain-specific language, which is described in \secref{sec:syntax}. The toolchain then parses the assertions into abstract syntax trees (ASTs), which are passed to the transformation stage. In this stage, the ASTs are transformed into ASTs that represent their negation. This is described further in \secref{sec:transformation}. The resulting ASTs are then passed to the backend, which is introduced in the subsequent chapter for the Tezos blockchain.

\section{Assertion syntax}\label{sec:syntax}
Tezos' Smart Contract language Michelson is a low-level and stack-based language. Specifying assertions that way is complex and inconvenient, especially if the language is compiled to other targets as well. Therefore, this thesis defines a domain-specific high-level language to express assertions. 

The syntax of this language is described in two versions by the EBNF grammars given in appendix \ref{apx:grammar}. One version implements a prefix and the other one an infix notation. The parser currently supports the prefix notation and correct operator precedences must be handled explicitly with parentheses. To avoid context switches (for developers on Tezos), the syntax is inspired by OCaml \cite{ocaml_docs} and uses the same type notations as Michelson.

\subsection{Code structure}
Assertions are passed to the toolchain as simple text files. This thesis follows the convention of using the file extension \texttt{.tza} for such files (henceforth referred to as ``assertion contracts'') in reference to the file extension \texttt{.tz}used for Michelson source files. Assertion contracts contain at least one assertion for a specific entrypoint of the actual contract (henceforth referred to as ``parent contract''). For the remaining entrypoints the compiler automatically generates empty assertions\footnote{cf. \secref{sec:compiler}}.

An assertion begins with the keyword \texttt{entrypoint} and a signature consisting of an optional tag denoted by \%, followed by a parameter pattern. Parameter patterns are similar to patterns in OCaml --- they are templates that match shapes of data structures and bind identifiers to the components of them. The given parameter pattern must match exactly the parameter type of the entrypoint it is associated with. The body of an assertion can contain a nesting of quantifiers and conditions around exactly one \texttt{assert} expression. Conditions can be used to restrict the quantification domains or for any other constraints. For completeness, the existential quantifier is already included in the grammar, however the current version of the pipeline will reject any assertions containing it. 

How the assertions are associated with the respective entrypoint of the parent contract depends on the Smart Contract language. In the case of Solidity, a tag that mirrors the function name is enough to link assertion and entrypoint. In Michelson contracts, on the other hand, entrypoints can be anonymous. Therefore, the assertions are linked to the entrypoints through the tags, the parameter type or both. \secref{sec:typecheck} describes in more detail how the linking is implemented in the Tezos backend.

\subsection{Parameter patterns}
\lstref{lst:patterns} gives an overview of the parameter patterns supported in the assertion language.
\lstinputlisting[caption=Patterns in the assertion language, language=, numbers=none, label=lst:patterns]{listings/patterns.txt}

By using patterns, developers can avoid the explicit handling of special cases, such as empty lists, in the assertion specification. Furthermore, they can be used to put emphasis on the relevant components of the input parameters by replacing the irrelevant ones with wildcards. As an example, the assertion given in \lstref{lst:patterns_usage} concerns the left element of a pair and only applies to non-empty lists. 
\begin{lstlisting}[label=lst:patterns_usage, language=Assertion, numbers=none]
(entrypoint %g (pair (cons a as) _)  ...)
\end{lstlisting}

\subsection{Types and operations}
In order to make the frontend generic, the sets of data types and operations supported by the grammar constitute unions of those present in the target languages. This not only the implementation of a single, common parser, but also allows the transformation to be oblivious of the target platform. As a consequence, the backends are responsible for performing a semantic check and  rejecting any assertions containing types or operations which are not supported by the target language.

The current version of the language contains all data types present in Tezos' VM and a subset of operations that Michelson provides (as of protocol version 007 Delphi). Besides the primitive types \texttt{int}, \texttt{nat} (natural numbers), \texttt{string}, \texttt{bool}, \texttt{bytes} and \texttt{unit}, this includes composite types like \texttt{list}, \texttt{pair}, \texttt{map} or the union type \texttt{or}. Domain specific data types, like \texttt{timestamp} or \texttt{address}, are supported as well. The data type \texttt{fmu} represents a generic fractional monetary unit, which is translated to the corresponding token type of the target platform\footnote{Mutez in Tezos, or Wei in Ethereum}.

The grammar currently includes common arithmetic (e.g., \texttt{add}, \texttt{sub}, \texttt{abs}, \texttt{mod}), relational  (e.g., \texttt{eq}, \texttt{neq}, \texttt{lt}) and logic and bitwise operators (e.g., \texttt{and}, \texttt{or}, \texttt{lsr}, \texttt{lsl}). Some operations that operate on data structures (e.g., \texttt{nth} and \texttt{size}) are supported as well. Domain specific operations have not been included yet, but they may be added to the language if necessary. 

\subsection{Example}
The example given in \lstref{lst:sorted_assertion} implements an assertion, which checks whether a list is sorted in ascending order based on a variation of the formula stated in \eqref{eq:sorted} in the introduction:
\begin{equation}\label{eq:sorted_v2}
	(\forall n,m : int) (0 \leq n < m < |a|) \Rightarrow a[n] \leq a[m]
\end{equation}
In contrast to the previous variation, which translates to an assertion that compares a random element of the list with its direct neighbour, this translates to a comparison of two random elements (under the constraint $n < m$). \lstref{lst:sorted_assertion} shows how this formula can be expressed in the assertion language.
\lstinputlisting[caption=Assertion contract for checking if a list is sorted, language=Assertion, label={lst:sorted_assertion}]{listings/sorted.tza}

In line 1, the signature of the assertion is declared with tag \textit{find} and a parameter \texttt{a} of type integer list. The body is a nesting of two universal quantifiers which declare the predicate variables $n$ and $m$ of type integer (lines 2 and 3), followed by a nesting of conditions to define the domains of the quantifiers (lines 4-6), corresponding to the premise of the formula. The body of the last condition (line 7) ultimately contains the keyword \texttt{assert} followed by the specification of the property to be checked, i.e.,  $a[n] \leq a[m]$.

\subsection{Extensions}\label{sec:ext}
In future iterations, the assertion syntax could be extended with some more features to improve usability and readability:
\begin{itemize}
\item \textbf{Local variables} to store, reuse and denominate computed values
\item \textbf{User-defined functions} to extract whole routines that can be reused in a single or even many assertion contracts, if defined as a module.
\item \textbf{if-else conditions} to adapt the domains of quantifications if certain conditions hold. The assertion that checks whether two numbers are relatively prime (discussed in \secref{sec:coprime}) is a good use-case for this feature: Firstly, the minimum of the given number has to be determined, however the \texttt{min}-function might not be supported as a built-in function by the target language (Tezos, for instance, does not support it). A solution for that could be to implement two branches in the program to handle each case. Secondly, if the greater of the two numbers is not evenly divided by the smaller one, the formula can be optimized by reducing the quantification domain by half to $(2 \le n \le \lfloor \frac{min(a,b)}{2} \rfloor)$, as a number cannot be evenly divided by any number between itself and its half \cite{bernhardt_veigel_2020}. With a syntax supporting an \texttt{if-else} control structure, the optimized assertion could look as follows:
\lstinputlisting[caption=Assertion syntax with if-else structures \cite{bernhardt_veigel_2020}, language=Assertion, label={lst:coprime}]{listings/coprime_ifelse.tza}
This feature is not included in the current version, because conditional domain restrictions make the translation from quantifiers to random generators or loops more complex. Aside from that, without the feature of variables and user-defined functions, the code is inflated significantly, thus causing increased origination cost.
\end{itemize}

\section{Parser}
Assertions expressed in the syntax described above are passed as a simple text file to the pipeline. It is not admissible to generate empty assertions for all entrypoints of the parent contract, hence empty files are rejected. Furthermore, the parser guarantees total success or total failure of parsing the assertion by aborting execution immediately after encountering a syntax error. 

After successfully parsing all assertions, the parser returns a list of ASTs. On the toplevel, the AST type given in \lstref{lst:ast_type} is composed of an entrypoint specification and an assertion body. The parameter pattern and assertion body, in turn, are  subtrees representing their composition or the content of the assertion respectively.
\begin{lstlisting}[label=lst:ast_type, language=, numbers=none, caption=Toplevel AST type definition in OCaml]
type ast =
  {entrypoint : string option * pattern; body : assertion}
\end{lstlisting}

\figref{fig:ast_example} shows the resulting AST after parsing the assertion given in \lstref{lst:sorted_assertion}. The subtype representing quantifiers contains a special field \textit{Bounds}, which is initially left empty by the parser. During the transformation, it is populated with a set of constraints concerning its predicate variable, cf. \secref{sec:transformation}.

\section{Transformation}\label{sec:transformation}
The assertion, as specified by a developer, is modified in two ways before the compiler translates it into target code: firstly, it has to be transformed into its negation. Secondly, quantifiers are converted to random generators, which generate values within a specified range (corresponding to the domains of discourse). In the assertion language, the ranges can be expressed using \texttt{if}-conditions. As a preliminary for the compilation, the transformation additionally analyses the condition nodes of the AST, identifies conditions that state a range constraint for a generator and assigns it to the respective quantification node (by adding it to the \textit{Bounds} field). Therefore, the transformation contains two consecutive steps:
\begin{enumerate}
\itemsep-0.5em
\item Negation
\item Domain constraint analysis and assignment
\end{enumerate}
Each step is described in more detail in the following subsections.

\subsection{Negation}
The formula is negated according to the negation rules of second-order predicate logic and by applying De Morgan's laws \cite{de_morgan} until the negation is applied to the literals. Negating universal quantification is equivalent to an existential quantification of its negated body (and vice versa): $\neg \forall x P(x) \equiv \exists x \neg P(x)$ \cite{Sundstrom2020Quantifiers}. The domain restrictions are not affected by the negation, which is also reflected in the rules of predicate logic if the domain is given as a premise in the logical formula: $\neg (p \Rightarrow q) \equiv p \Rightarrow \neg q $.

Applied to an AST representation of the assertion, the negation recursively traverses the \texttt{assertion} subtree, replaces quantifier and expression nodes with the corresponding negations and skips condition nodes. The output is thus a modified AST. 
Further pursuing the example of the assertion for sorted lists, the negated version of the AST given in \figref{fig:ast_example} is shown in \figref{fig:ast_example_neg}. The universal quantifiers have been transformed to existential quantifiers, and the asserted condition from $a[n] <= a[m]$ to $a[n] > a[m]$.

\begin{figure}[t]
\hfill
\subfloat[AST after parsing\label{fig:ast_example}]{%
  \includegraphics[width=0.33\textwidth]{figures/3-offline/ast_example_find}
}
\subfloat[Negated AST\label{fig:ast_example_neg}]{%
  \includegraphics[width=0.33\textwidth]{figures/3-offline/ast_example_neg}
}
\hfill
\subfloat[Fully transformed AST\label{fig:ast_example_transf}]{%
  \includegraphics[width=0.3\textwidth]{figures/3-offline/ast_example_transf}
}
\caption{Modifications to the sorted list assertion AST from parsing to completed transformation}
\end{figure}

\subsection{Domain assignment}
In order to obtain random generators which only generate values in the interesting range, i.e., within the domains of discourse, the second step of the transformation skims the condition nodes of the AST for atomic constraints that contain bound variables. These conditions are then moved to the \texttt{Bounds} field of the respective quantifier. If the constraint contains more than one bound variable, it is assigned to the quantifier with the highest depth in the quantifier nesting, as they depend on the generated values of the previous generators. \\
Relating to the example of sorted lists, the premise in \eqref{eq:sorted_v2} can be considered as a conjunction of the four constraints
\begin{enumerate}
\itemsep-1em
\item $0 \leq n$
\item $n < |a| $
\item $n \le m$ and
\item $m < |a|$.
\end{enumerate}
Constraint 1,2 and 4 only contain one bound variable ($n$ or $m$), thus they are assigned to the respective quantifier binding it. Constraint 3, on the other hand, features two bound variables -- this constraint is assigned to the quantifier last in the nesting, thus the quantifier binding $m$. The corresponding AST expressing this assignment is shown in \figref{fig:ast_example_transf}. 

During compilation, the quantifiers, and their list of bounds, are then translated to target code that corresponds to the following pseudocode (\lstref{lst:rand}):
\begin{lstlisting}[label=lst:rand, caption=Random generators for sorted list assertion, numbers=none]
n = random(0, size(a))
m = random(n + 1, size(a))
\end{lstlisting}

However, if constraints contain certain operators, deriving efficient random generators is less straight-forward. Consider the following constraints:
\begin{enumerate}
\itemsep-0.7em
\item $(\forall n : int) (n < 10 \lor n > 20) ...$
\item $(\forall n : int) (n \ne 10) ...$
\item $(\forall n : int) (n = 10) ...$
\end{enumerate}
Constraint 1 can complicate restricting the range of the random generator in two ways. Firstly, it separates the range into two disjoint sub-ranges, which translates to a random generator as shown in \lstref{lst:rand_disjoint}.
\begin{lstlisting}[label=lst:rand_disjoint, caption=Random generator with two disjoint ranges, numbers=none]
n = if random(0,2) == 0 then random(-MAX_INT, 10)
                        else random(21, MAX_INT)
\end{lstlisting}
Secondly, the operands of a disjunction cannot be considered separately if they involve several bound variables. For the predicate variable whose random generator is executed first, the domain restriction is optional, while the generation of the following random values depend on the previous result. \lstref{lst:rand_disjoint_nm} shows the corresponding random generators for a variation of constraint 1 featuring two bound variables, i.e., $(\forall n,m) (n < 10 \lor m > 20)...$.
\begin{lstlisting}[label=lst:rand_disjoint_nm, caption=Random generators with two disjoint ranges and two bound variables, numbers=none]
n = if random(0,2) == 0 then random(-MAX_INT, 10)
                        else random(-MAX_INT, MAX_INT)
m = if n < 10 then random(-MAX_INT, MAX_INT)
              else random(20, MAX_INT)
\end{lstlisting}
Similarly to 1, constraint 2 splits the domain into sub-domains. Constraint 3 effectively makes the quantifier binding $n$ obsolete and thus can be translated to a variable with a constant value.

In the current implementation of the transformation, constraints featuring the logical or, exclusive or or inequality operator are kept as part of the assertion body. They are considered to be exceptional cases, but will increase the overall complexity of the compilation beyond the scope of a first iteration. In the case that constraints remain part of the assertion body, they are checked during runtime. As a consequence, an invocation of the assertion contract can result in a futile assertion check if such a condition is not met.

\subsubsection{Implicit constraints}
In some cases, boundaries are imposed to the random generators implicitly through the used data types. List indices, for instance, are always bound to the range $0.. size(list) - 1$ and could thus be derived from the formula without an explicit specification. As this requires a semantic analysis of the AST and thus a more complex transformation, the current implementation requires a completely explicit formula in terms of the domains. 

Depending on the blockchain VM, the lower bound for generated values used in indexing operations can be implicitly handled by the random generator of an appropriate predicate variable type. As an example, Michelson supports the data type \texttt{nat} representing the natural numbers, which categorically excludes all values below zero. \eqref{eq:sorted_v2} can thus be abbreviated with the formula given in \eqref{eq:sorted_v2_abbr}.
\begin{equation}\label{eq:sorted_v2_abbr}
	(\forall n : nat)(\forall m : nat) (n \le m < |a|) \Rightarrow a[n] \leq a[m]
\end{equation}