\chapter{Offline Design}\label{chap:offline}
Implementing distributed assertion checking on Tezos requires some off-chain considerations and infrastructure. The previous chapter defined a formal set of logical formulae amenable for this approach and gave some in-depth examples. As was stated before, the proposed implementation in the following chapters is restricted to formulas of predicate logic using universal quantification.\\
The goal of the offline infrastructure is to provide a syntax for stating an assertion that checks a logical formula. Furthermore, these assertions need to be transformed, s.t. they check for counterexamples, and compiled into Michelson code to extend the actual smart contract. This chapter describes a concrete syntax for writing these assertions, and shows how some of the previously given examples are expressed using it. The transformation of the original assertions to assertions that check for counterexamples or proofs is formalized in \secref{sec:transformation}. \todo{rest}

\section{Assertion syntax}

Argument against if/else conditions outside of assert():
In order to take advantage of this, the assertion syntax would need to be able to create different generators for different conditions. Currently, we only allow \texttt{if-else} instructions inside an \texttt{assertion} expression; this use-case could be an argument to lift that restriction and allow contracts like this:
%\lstinputlisting[caption=Assertion contract with conditional generators, label={lst:coprime}]{listings/coprime.tza}

However, this will make the transformation more involved, as the bounds cannot simply be merged with the generator anymore.

\section{Transformation}\label{sec:transformation}
Since the validators will check the input parameter for the negation of the formula, it has to be transformed before the compilation. Furthermore, the formula should explicitly state the domain for each quantifier, which will have to be translated into a set of bounds that belong to the respective random generator. These restrictions are important in order to avoid wasting resources through testing values out of the relevant (or legal) scope.

\subsection{Negation}
The formula is negated using the negation rules of second-order logic and applying De Morgan's laws until the negation is applied to the literals. Negating universal quantification is equivalent to an existential quantification of its negated body (and vice versa): $\neg \forall x P(x) \equiv \exists x \neg P(x)$. The domain restrictions are not affected by the negation - the domain of the statement remains the same. This is also reflected in the rules of predicate logic, if the domain restrictions are given as a premise in the logical formula: $\neg (p \Rightarrow q) \equiv p \Rightarrow \neg q $.

% Nested forall -> exists and reverse: no negation?

\subsection{Defining the domain of random generators}
In order to assign each explicit bound to the respective quantifier, the formula has be skimmed for atomic constraints that contain bound variables. They're then moved and assigned to the quantifier that bounds the variable. If the constraint contains more than one, it is assigned to the quantifier with the highest depth in the order of quantifiers. \\
Consider a variation of the example given in \eqref{eq:sorted}, a formula checking if a given list is sorted:
\begin{equation}\label{eq:sorted_v2}
	(\forall n : int)(\forall m : int) (0 \leq n \le m < |a|) \Rightarrow a[n] \leq a[m]
\end{equation}
The premise can be considered as a conjunction of the four constraints $0 \leq n$, $n < |a| $, $n \le m$ and $m < |a|$. Applying the rules given above after negating the formula, the constraints are assigned to the quantifiers as follows:
\begin{equation}\label{eq:sorted_v2_bounds}
	(\exists n : int, 0 \leq n \wedge n < |a|)(\exists m : int, m > n \wedge m < |a|) \text{ } a[n] > a[m]
\end{equation}
Ultimately, the quantifiers are then translated to the corresponding random generators shown in \lstref{lst:rand}.
\begin{lstlisting}[label=lst:rand]
n = random(0, size(list))
m = random(n, size(list))
\end{lstlisting}

While conjunctions can be handled easily, other operators make it more difficult to derive efficient random generators. Consider the following constraints:
\begin{align}
(\forall n : int) (n < 10 \lor n > 20) ... \\
(\forall n : int) (n \ne 10) ... \\
(\forall n : int) (n = 10) ... 
\end{align}

Both constraints 1) and 2) complicate restricting the random generator in several ways. Firstly, they separate the domain into two disjoint sub-domains, which requires defining a random generator for each range and another one to decide which one is called. Secondly, the operands of a disjunction cannot be considered separately when more than one bound variable is involved. For the predicate whose random generator is executed first, the domain restriction is optional, while the generation of the following random values depend on the previous result. As the complexity of building efficient random generators in these cases is relatively high, restrictions formulated with these operators are kept, for now, as part of the assertion code rather than used as constraints for the generators. Consequently, some validators may generate irrelevant values when checking the assertion. Depending on the size of the gap between the sub-domains, this can significantly decrease the reliability of this kind of assertion checking. Constraint 3) effectively makes the quantifier, which binds $n$, obsolete. Adding this constraint to the respective generator will at least not affect the reliability, but a future improvement could be to optimize the assertion by replacing all occurrences of the bound variable with the assigned value and removing the quantification.\\

In some cases, boundaries are given implicitly by data types. List indices, for instance, are always bound to the range $0.. size(list) - 1$ and could thus be derived from the formula without an explicit specification. As this deduction makes the transformation more complex, as it requires a semantic analysis of the formula, a completely explicit formula in terms of the domain is required for now. Depending on the virtual machine, the lower bound for indexing operations can be handled by the random generator of an appropriate predicate type. As an example, Michelson supports the data type \texttt{nat} representing the natural numbers, which categorically excludes all values below zero. Developers aware of this can exploit this and, for instance, abbreviate \eqref{eq:sorted_v2} with the following formula:
\begin{equation}\label{eq:sorted_v2_abbr}
	(\forall n : nat)(\forall m : nat) (n \le m < |a|) \Rightarrow a[n] \leq a[m]
\end{equation}

\subsection{Interesting formulae}\label{sec:example_formulae}
- paper


- First of all some offline stuff to think about - formalize which formulas are amenable for this checking. Formalize what to do for which formulas (exists/forall/mixed) etc.
- Grammar/language to express these formulas (still general, not protocol specific)
	-> which operations do we need?
	-> use the form of expose?
	-> uses ocaml/michelson like syntax; used by other BC as well though
- effectiveness
- formalize the costs for checking these formulas



New Section/chapter? %\section{Implementation}
- grammar ? concrete syntax; examples from examples :D
- Tezos specific: what does VM support? needed extensions?
	-> compilation target -> what is the result supposed to look like?
- Description of pipeline
- 



effectiveness:
smaller search spaces = less needed test runs
example sorted list -> generate 1 random number and check neighbor = many test runs to cover all of them
partition search space \& generate 2 random numbers better? -> 2 smaller search spaces. would this improve anything?



\begin{lstlisting}[numbers=none, language=Assertion]
(entrypoint (left (right (pair ( a : address) _)))
  (forall (i : int)
     (if (gt i 10)
       (assert true))))
\end{lstlisting}