\chapter{Tezos}
The Tezos blockchain is presented in its Whitepaper as a \enquote{generic and self-amending crypto-ledger} \cite{goodman_tezos_2014}. It uses a proof-of-stake consensus mechanism that is not only used to agree on the current state of its ledger, but also allows its stakeholders to come to a consensus about changes in the economic protocol by a voting process. These changes included in a protocol upgrade, i.e. amendment, can influence which transactions are valid on the blockchain, the payment system or even the voting process itself without risking a fork of the blockchain. Everyone owning the cryptocurrency of Tezos, called Tez, is considered a stakeholder. The Whitepaper compares the self-amending protocol to Peter Suber's game Nomic \cite{nomic}, and a similar concept was also implemented in the virtual sports league Blaseball \cite{blaseball}, which became popular during the COVID-19 pandemic. In addition to user accounts associated with a public key, Tezos supports smart contracts, which are written in the built-in language Michelson. Tezos' transaction fee system is similar to Ethereum's - it is gas-instrumented and besides a base fee, every operation and byte of storage has to be paid for. However, Tezos imposes a hard cap on the amount of gas that can be consumed per transaction, whereas Ethereum limits the gas quota only in respect to blocks \cite{wood_ethereum_2021}.\\
Compiling the Tezos source code yields five essential binaries: the node, baker, endorser, accuser and client. The node is the entity that connects to the peer-to-peer network and keeps a copy of the chain. Bakers are responsible for producing new blocks, the endorsers for signing blocks and the accusers to call out bakers or endorsers which double-sign or -endorse. The client provides a command line interface to interact with the local node through remote procedure calls (RPC).

\section{Michelson}
Michelson is a lower-level, stack-based language with a strict type-checking and supports primitive data types, like integers or strings, as well as high-level data structures such as list, maps and sum types \cite{tezos_docs_michelson}. The type system reduces the occurrence of runtime errors and ensures that only well-typed contracts are originated on the blockchain. In OCaml the typing rules are implemented using generalized algebraic data types (GADTs) \cite{tezos_docs_michelson} and thus enforced by OCaml's typechecker. \\
The concrete syntax of Michelson is called Micheline. A program is represented in Micheline nodes, which can be a constant of type integer, string or byte sequence, or an application of a primitive, given as a string keyword, to a list of nodes. For documentation, readability and additional type constraints, Michelson and Micheline also offer three types of annotations - type, variable and field or constructor annotations, which are labelled with a unique special character in Micheline. The toplevel structure of a smart contract consists of a sequence of the three primitive applications \texttt{parameter, storage} and \texttt{code}, declaring the type of the input parameter, the storage type and the actual program code. Unlike in the contracts given in the introduction, described with the syntax of Solidity, Michelson doesn't have a concept of named functions with individual input parameter types. 

\todo{Citations}
\todo{Put Michelsons grammar/list of operations in appendix?}

\subsection{Entrypoints}
Instead of named functions, Michelson programs can have separate entry points by taking a disjunctive type as input parameter and tagging the type constructors with a "function" name. The disjunctive type is built by nesting the \texttt{or} type, which has the constructors \texttt{left} and \texttt{right}. Assume we want to implement the contract from \lstref{lst:prime} in Michelson and add another function to it, which expects a string parameter. Omitting the actual program, the contract type declaration looks as follows:
\begin{lstlisting}[language=Michelson, numbers=none]
parameter (or (int %isPrime) (string %isUpper));
storage unit;
code { ... }
\end{lstlisting}
The input type declared in the primitive application \texttt{parameter} accepts input of either type \texttt{left int}, or \texttt{right string}. By adding the field annotations \texttt{isPrime} and \texttt{isUpper} the entry points are given tags and can be called explicitly by an external transaction. In that case, parameters of type \texttt{int} or \texttt{string} are accepted and the value is automatically wrapped into the wrapped into the respective constructors. It's possible to declare a \texttt{default} entrypoint, which is called when no explicit tag is specified and is by default assigned to the root of the parameter type.

\todo{Citations}

\section{OCaml}
The Tezos blockchain itself is implemented in the functional programming language OCaml, which emphasizes expressiveness and safety \cite{ocaml_doc}. It is statically type-checked and features parametric polymorphism and type inference. Developers can define algebraic data types and selectively apply functions to them using pattern-matching. The memory management is automatically handled by a garbage collector. Another notable feature of OCaml is its well-designed module system that allows organizing code in a module hierarchy and defining functors to create parametrized modules.\\
In \cite{canou_tezos_nodate}, the developers of the Tezos blockchain emphasize the importance of safety and security and speed for implementing Tezos, which OCaml is able to ensure through its static type-system and efficient compiler. The module system allowed to encapsulate and abstract the economic protocol to make it replaceable. Furthermore, OCamls ecosystem includes many tools for formal verification, in order to prove the correctness of both the protocol and Michelson smart contracts.

\todo{Citations}

\section{Developer tools in the Tezos ecosystem}
This section describes some relevant tools and projects for developers that are part of Tezos' ecosystem.

\subsection{Tezos Libraries}
Tezos' executables and libraries are available on \texttt{opam}, which is OCamls package manager \cite{tezos_opam}. The protocol libraries of every version are released separately, thus projects can be built on the protocol of choice. Important libraries that were used in this thesis are Tezos' Micheline library providing the internal abstract syntax tree (AST) and parser of the Michelson language, as well as the protocol specific libraries containing the typechecker.

\subsection{Testing tools}
Before a new protocol is proposed to the Tezos network, it has to be thoroughly tested with system, integration and regression tests. Of course this requires a sandboxed network to simulate the real peer-to-peer network, such that also interactions between the actors of the blockchain can be tested. Tezos provides two testing frameworks for this:

\begin{itemize}
\item[Flexible Network Sandboxes (Flextesa)] With Flextesa one can configure and run a small, fully functional sandboxed test network including nodes, bakers, endorsers and accusers. Accounts can be instantiated and used to send or receive funds. Configurable are, for instance, the size of the network, the time between blocks or enabling generation of random network traffic. Networks may either be fully autonomous, baking blocks automatically, or require manual baking of blocks. It also supports interactive sessions, where the tester can interact with the blockchain using the Tezos client. Flextesa's typical use-cases are interactive testing scenarios like double-baking, the voting process or protocol amendments. The Tezos repository already provides ready-to-use scenarios for accusations. Besides testing shell or protocol code, Flextesa can also be used to test smart contracts.\cite{tezos docs}
\item[Tezt] The Tezt framework is newer than Flextesa and planned as its replacement. It can also launch the Tezos binaries as external processes and build a sandboxed test network of configurable size. Its main advantages over Flextesa are simplicity, usability and the use of events instead of polling the node.\cite{tezos_docs_tezt}
\end{itemize}

\subsection{High-level languages}
Michelson is a compilation target for various high-level languages that provide more user-friendly and intuitive way of writing smart contracts. Additionally, some of them come with development environments, testing or verification tools. The following list comprises of the three most prominent languages that compile to Michelson:
\begin{itemize}
\item[\textbf{Liquidity}] is a language with an Ocaml-like syntax, which allows using local variables instead of stack manipulations. Its module system can be used to write reusable contract code or libraries. Besides an optimizing compiler, the project also includes a decompiler to compile Michelson programs to Liquidity. \cite{liquidity}
\item[\textbf{SmartPy}] is a language available through a Python library and lets developers write contracts and tests in Python. Its developer suite includes i.a. a compiler, a simulation engine and an online editor. \cite{smartpy}
\item [\textbf{fi}] 's syntax similar to JavaScript or Ethereum's contract language Solidity. It also provides an online editor and a simulator to test against the compiled contracts. However, it seems extensions to Michelson introduced by newer protocol versions are not supported yet. \cite{https://fi-code.com/}
\end{itemize}